
<div class="lesson-article">
  <h2 class="article-title">两数之和</h2>
  <p>给定一个整数数组，和一个目标整数。设计一个算法，找出数组中两个整数的index位置，这两个整数加起来等于给定的目标整数。
    只需找出其中一个答案即可。
  例如:</p>
  <pre>
    给定整数数组 nums = [2, 18，7, 11, 15], target = 9,
    由于 nums[0] + nums[2] = 2 + 7 = 9,
    结果返回 [0, 2]。
  </pre>

  <div>
    <h4>分析:</h4>
    <ul>
      <li>题目没有说数组是有序的;</li>
      <li>数组中的整数可能是正整数，负整数或零;</li>
      <li>我们应该考虑给定的数组为空的边界情况;</li>
      <li>只需要找出一个答案即可;</li>
    </ul>
    <p>
      让我们从头开始依次扫描数组中的每一个整数，并额外使用一个 map 数据结构来帮助记忆那些已经扫描过的整数以及对应的index位置。
      假设现在程序扫描到位置<code>i</code>, 而 map 里存放着我们已经见过的数字(也就是 index 从 0 到 i - 1 的数字)。
      只要 map 中存在一个整数, 等于<code>target - nums[i]</code>, 那么我们就成功找到答案了。
    </p>
    <pre>
class Solution:
    def two_sum(nums, target):
        m = {}
        for i, x in enumerate(nums):
            y = target - x
            if y in m: # 当找到一个答案后,函数调用直接返回结果。
                return [m[y], i]
            else:
                m[x] = i
        # 程序执行到这里，数组中所有的整数都已经扫描完毕，仍然没有找到答案, 则返回空列表。
        return []
    </pre>
    <p>现在, 让我们检查边界输入的情况，看我们的程序能否处理空数组的情况。
      假设给定的数组为空，上面的程序是不会进入<code>for</code>循环的, 而是直接返回空的列表<code>[]</code>。
      也就是说, 我们设计的算法已经覆盖了这种边界输入情况, 不需要进行另外的处理。
    </p>
    <p></p>
  </div>
</div>